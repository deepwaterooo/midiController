% Created 2015-04-17 Fri 22:16
\documentclass[9pt,b5paper]{article}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{xeCJK}
\setCJKmainfont{SimSun}
\usepackage{longtable}
\usepackage{float}
\usepackage{textcomp}
\usepackage{geometry}
\geometry{left=0cm,right=0cm,top=0cm,bottom=0cm}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{latexsym}
\usepackage{natbib}
\usepackage{fancyhdr}
\usepackage[xetex,colorlinks=true,CJKbookmarks=true,linkcolor=blue,urlcolor=blue,menucolor=blue]{hyperref}


\lstset{language=c++,numbers=left,numberstyle=\tiny,basicstyle=\ttfamily\small,tabsize=4,frame=none,escapeinside=``,extendedchars=false,keywordstyle=\color{blue!70},commentstyle=\color{red!55!green!55!blue!55!},rulesepcolor=\color{red!20!green!20!blue!20!}}
\author{deepwaterooo}
\date{\today}
\title{QThread Re-entrant \& thread-Safe}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7c)}}
\begin{document}

\maketitle
\tableofcontents


\section{QT的信号与槽机制}
\label{sec-1}
\subsection{概述}
\label{sec-1-1}
\begin{itemize}
\item 所有从 QObject或其子类(例如Qwidget)派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射(emit)出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。而且，对象并不了解具体的通信机制。
\item 你可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。
\end{itemize}
\subsection{信号}
\label{sec-1-2}
\begin{itemize}
\item 信号-槽机制完全独立于任何GUI事件循环。只有当所有的槽返回以后发射函数（emit）才返回。如果存在多个槽与某个信号相关联，那么，当这个信号被发射时，这些槽将会一个接一个地执行，但是它们执行的顺序将会是随机的、不确定的，我们不能人为地指定哪个先执行、哪 个后执行。
\item 信号的声明是在头文件中进行的，QT的signals关键字指出进入了信号声明区，随后即可 声明自己的信号。例如，下面定义了三个信号：

\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
signals:  
    void mySignal();  
    void mySignal(int x);  
    void mySignalParam(int x,int y);
\end{lstlisting}

\item 在上面的定义中，signals是QT的关键字，而非C/C++的。接下来的一行void mySignal() 定义了信号mySignal，这个信号没有携带参数；接下来的一行void mySignal(int x)定义了重名信号mySignal，但是它携带一个整形参数，这有点类似于C++中的虚函数。从形式上讲信号的声明与普通的C++函数是一样的，但是信号却没有函数体定义，另外，信号的返回 类型都是void，不要指望能从信号返回什么有用信息。
\item 信号由moc自动产生，它们不应该在.cpp文件中实现。
\end{itemize}
\subsection{槽}
\label{sec-1-3}
\begin{itemize}
\item 槽是普通的C++成员函数，可以被正常调用，它们唯一的特殊性就是很多信号可以与其相关联。当与其关联的信号被发射时，这个槽就会被调用。槽可以有参数，但槽的参数不能有缺省值。
\item 既然槽是普通的成员函数，因此与其它的函数一样，它们也有存取权限。槽的存取权限决定了谁能够与其相关联。同普通的C++成员函数一样，槽函数也分为三种类型，即public slots、private slots和protected slots。
\begin{itemize}
\item public slots：在这个区内声明的槽意味着任何对象都可将信号与之相连接。这对于组件编程非常有用，你可以创建彼此互不了解的对象，将它们的信号与槽进行连接以便信息能够正确的传递。
\item protected slots：在这个区内声明的槽意味着当前类及其子类可以将信号与之相连接。这适用于那些槽，它们是类实现的一部分，但是其界面接口却面向外部。
\item private slots：在这个区内声明的槽意味着只有类自己可以将信号与之相连接。这适用于联系非常紧密的类。
\end{itemize}
\item 槽也能够声明为虚函数，这也是非常有用的。
\item 槽的声明也是在头文件中进行的。例如，下面声明了三个槽：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
public slots:   
    void mySlot();   
    void mySlot(int x);   
    void mySignalParam(int x,int y);
\end{lstlisting}
\end{itemize}
\subsection{信号与槽的关联}
\label{sec-1-4}
\begin{itemize}
\item 通过调用QObject对象的connect函数来将某个对象的信号与另外一个对象的槽函数相关联，这样当发射者发射信号时，接收者的槽函数将被调用。该函数的定义如下：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
bool QObject::connect ( const QObject * sender, const char * signal,  
			const QObject * receiver, const char * member ) [static]
\end{lstlisting}

\item 这个函数的作用就是将发射者sender对象中的信号signal与接收者receiver中的member槽函数联系起来。当指定信号signal时必须使用QT的宏SIGNAL()，当指定槽函数时必须使用宏SLOT()。如果发射者与接收者属于同一个对象的话，那么在connect调用中接收者参数可以省略。
\item 一个信号甚至能够与另一个信号相关联，看下面的例子：

\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
class MyWidget : public QWidget {  
public:  
    MyWidget();  
    //    ...  
signals:  
    void aSignal();  
    //    ...  
private:  
    //    ...  
    QPushButton *aButton;  
};  

MyWidget::MyWidget() {  
    aButton = new QPushButton( this );  
    connect(aButton, SIGNAL(clicked()), SIGNAL(aSignal()));  
}
\end{lstlisting}

\item 在上面的构造函数中，MyWidget创建了一个私有的按钮aButton，按钮的单击事件产生的信号clicked()与另外一个信号aSignal ()进行了关联。这样一来，当信号clicked()被发射时，信号aSignal()也接着被发射。当然，你也可以直接将单击事件与某个私有的槽函数相关联，然后在槽中发射aSignal()信号，这样的话似乎有点多余。
\item 当信号与槽没有必要继续保持关联时，我们可以使用disconnect函数来断开连接。其定义如下：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
bool QObject::disconnect ( const QObject * sender, const char * signal,  
			   const Object * receiver, const char * member ) [static]
\end{lstlisting}

\item 这个函数断开发射者中的信号与接收者中的槽函数之间的关联。
\item 有三种情况必须使用disconnect()函数：
\begin{itemize}
\item 断开与某个对象相关联的任何对象。这似乎有点不可理解，事实上，当我们在某个对象中定义了一个或者多个信号，这些信号与另外若干个对象中的槽相关联，如果我们要切断这些关联的话，就可以利用这个方法，非常之简洁。
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
disconnect( myObject, 0, 0, 0 )
\end{lstlisting}

或者
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
myObject->disconnect()
\end{lstlisting}
\item 断开与某个特定信号的任何关联。
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
disconnect( myObject, SIGNAL(mySignal()), 0, 0 )
\end{lstlisting}

或者

\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
myObject->disconnect( SIGNAL(mySignal()) )
\end{lstlisting}
\item 断开两个对象之间的关联。
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
disconnect( myObject, 0, myReceiver, 0 )
\end{lstlisting}
或者
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
myObject->disconnect(　myReceiver )
\end{lstlisting}
\end{itemize}
\item 在disconnect函数中0可以用作一个通配符，分别表示任何信号、任何接收对象、接收对象中的任何槽函数。但是发射者sender不能为0，其它三个参数的值可以等于0。
\end{itemize}
\subsection{元对象工具}
\label{sec-1-5}
\begin{itemize}
\item 元对象编译器moc（meta object compiler）对C++文件中的类声明进行分析并产生用于初始化元对象的C++代码，元对象包含全部信号和槽的名字以及指向这些函数的指针。
\item moc读C++源文件，如果发现有Q$_{\text{OBJECT宏声明的类，它就会生成另外一个C}}$++源文件，这个新生成的文件中包含有该类的元对象代码。例如，假设我们有一个头文件mysignal.h，在这个文件中包含有信号或槽的声明，那么在编译之前 moc 工具就会根据该文件自动生成一个名为mysignal.moc.h的C++源文件并将其提交给编译器；类似地，对应于mysignal.cpp文件moc 工具将自动生成一个名为mysignal.moc.cpp文件提交给编译器。
\item 元对象代码是signal/slot机制所必须的。用moc产生的C++源文件必须与类实现一起进行编译和连接，或者用\#include语句将其包含到类的源文件中。moc并不扩展\#include或者\#define宏定义,它只是简单的跳过所遇到的任何预处理指令。
\end{itemize}
\subsection{examples}
\label{sec-1-6}
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
//tsignal.h  
class TsignalApp : public QMainWindow {  
    Q_OBJECT  

    //信号声明区  
signals:  
    //声明信号mySignal()  
    void mySignal();  
    //声明信号mySignal(int)  
    void mySignal(int x);  
    //声明信号mySignalParam(int, int)  
    void mySignalParam(int x, int y);  

    //槽声明区  
public slots:  
    //声明槽函数mySlot()  
    void mySlot();  
    //声明槽函数mySlot(int)  
    void mySlot(int x);  
    //声明槽函数mySignalParam (int，int)  
    void mySignalParam(int x, int y);  
};

//tsignal.cpp  
TsignalApp::TsignalApp()   {  
    //将信号mySignal()与槽mySlot()相关联  
    connect(this, SIGNAL(mySignal()), SLOT(mySlot()));  
    //将信号mySignal(int)与槽mySlot(int)相关联  
    connect(this, SIGNAL(mySignal(int)), SLOT(mySlot(int)));  
    //将信号mySignalParam(int, int)与槽mySlotParam(int, int)相关联  
    connect(this, SIGNAL(mySignalParam(int, int)), SLOT(mySlotParam(int, int)));  
}  

// 定义槽函数mySlot()  
void TsignalApp::mySlot()   {  
    QMessageBox::about(this, "Tsignal",  "This is a signal/slot sample without parameter.");  
}  

// 定义槽函数mySlot(int)  
void TsignalApp::mySlot(int x)   {  
    QMessageBox::about(this, "Tsignal",  "This is a signal/slot sample with one parameter.");  
}  

// 定义槽函数mySlotParam(int, int)  
void TsignalApp::mySlotParam(int x, int y)   {  
    char s[256];  
    sprintf(s, "x:%d y:%d", x, y);  
    QMessageBox::about(this, "Tsignal",  s);  
}  
void TsignalApp::slotFileNew()   {  
    //发射信号mySignal()  
    emit mySignal();  
    //发射信号mySignal(int)  
    emit mySignal(5);  
    //发射信号mySignalParam(5，100)  
    emit mySignalParam(5, 100);  
}
\end{lstlisting}
\subsection{应注意的问题}
\label{sec-1-7}
\begin{itemize}
\item 1．信号与槽的效率是非常高的，但是同真正的回调函数比较起来，由于增加了灵活性，因此在速度上还是有所损失，当然这种损失相对来说是比较小的，通过在一台i586-133的机器上测试是10微秒（运行Linux），可见这种机制所提供的简洁性、灵活性还是值得的。但如果我们要追求高效率的话，比如在实时系统中就要尽可能的少用这种机制。
\item 2．信号与槽机制与普通函数的调用一样，如果使用不当的话，在程序执行时也有可能产生死循环。因此，在定义槽函数时一定要注意避免间接形成无限循环，即在槽中再次发射所接收到的同样信号。例如,在前面给出的例子中如果在mySlot()槽函数中加上语句emit mySignal()即可形成死循环。
\item 3．如果一个信号与多个槽相联系的话，那么，当这个信号被发射时，与之相关的槽被激活的顺序将是随机的。
\item 4. 宏定义不能用在signal和slot的参数中。
\begin{itemize}
\item 既然moc工具不扩展\#define，因此，在signals和slots中携带参数的宏就不能正确地工作，如果不带参数是可以的。例如，下面的例子中将带有参数的宏SIGNEDNESS(a)作为信号的参数是不合语法的：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
#ifdef ultrix  
#define SIGNEDNESS(a) unsigned a  
#else  
#define SIGNEDNESS(a) a  
#endif  
class Whatever : public QObject {  
    signals:  
    void someSignal( SIGNEDNESS(a) );  
};
\end{lstlisting}
\end{itemize}
\item 5.构造函数不能用在signals或者slots声明区域内。
\begin{itemize}
\item 的确，将一个构造函数放在signals或者slots区内有点不可理解，无论如何，不能将它们放在private slots、protected slots或者public slots区内。下面的用法是不合语法要求的：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
class SomeClass : public QObject {  
    Q_OBJECT  
public slots:  
    SomeClass( QObject *parent, const char *name )  
	: QObject( parent, name ) {}　// 在槽声明区内声明构造函数不合语法  
};
\end{lstlisting}
\end{itemize}
\item 6. 函数指针不能作为信号或槽的参数。
\begin{itemize}
\item 例如，下面的例子中将void (\textbf{applyFunction)(QList}, void*)作为参数是不合语法的：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
class someClass : public QObject   {  
    Q_OBJECT  
public slots:  
    void apply(void (*applyFunction)(QList*, void*), char*); // 不合语法  
};
\end{lstlisting}
\item 你可以采用下面的方法绕过这个限制：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
typedef void (*ApplyFunctionType)(QList*, void*);  
class someClass : public QObject {  
    Q_OBJECT  
    public slots:  
    void apply( ApplyFunctionType, char *);  
};
\end{lstlisting}
\end{itemize}
\item 7. 信号与槽不能有缺省参数。
\begin{itemize}
\item 既然signal->slot绑定是发生在运行时刻，那么，从概念上讲使用缺省参数是困难的。下面的用法是不合理的：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
class SomeClass : public QObject {  
    Q_OBJECT  
public slots:  
    void someSlot(int x = 100); // 将x的缺省值定义成100，在槽函数声明中使用是错误的  
};
\end{lstlisting}
\end{itemize}
\item 8. 信号与槽也不能携带模板类参数。
\begin{itemize}
\item 如果将信号、槽声明为模板类参数的话，即使moc工具不报告错误，也不可能得到预期的结果。 例如，下面的例子中当信号发射时，槽函数不会被正确调用：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
public slots:  
    void MyWidget::setLocation (pair location);  
public signals:
    void MyObject::moved (pair location);
\end{lstlisting}
\item 但是，你可以使用typedef语句来绕过这个限制。如下所示：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
typedef pair IntPair;  
public slots:  
    void MyWidget::setLocation (IntPair location);  
public signals:  
    void MyObject::moved (IntPair location);
\end{lstlisting}
\item 这样使用的话，你就可以得到正确的结果。
\end{itemize}
\item 9. 嵌套的类不能位于信号或槽区域内，也不能有信号或者槽。
\begin{itemize}
\item 例如，下面的例子中，在class B中声明槽b()是不合语法的，在信号区内声明槽b()也是不合语法的。 class A
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
class A {  
    Q_OBJECT  
public:  
    class B {  
	public slots:　 // 在嵌套类中声明槽不合语法  
	    void b();  
    };  
signals:  
    class B {  
	// 在信号区内声明嵌套类不合语法  
	void b();  
    }:  
};
\end{lstlisting}
\end{itemize}
\item 10.友元声明不能位于信号或者槽声明区内。相反，它们应该在普通C++的private、protected或者public区内进行声明。下面的例子是不合语法规范的：
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
class someClass : public QObject {  
    Q_OBJECT  
signals: //信号定义区  
    friend class ClassTemplate; // 此处定义不合语法
};
\end{lstlisting}
\end{itemize}

\section{Qt多线程之可重入与线程安全}
\label{sec-2}
\begin{itemize}
\item \textbf{可重入} ： 假如一个类的任何函数在此类的多个不同的实例上，可以被多个线程同时调用，那么这个类被称为是“可重入”的。
\item \textbf{线程安全} ： 假如不同的线程作用在同一个实例上仍可以正常工作，那么称之为“线程安全”的。
\end{itemize}
\subsection{QObject可重入性}
\label{sec-2-1}
\begin{itemize}
\item QObject是可重入的。它的大多数非GUI子类，像QTimer,QTcpSocket,QUdpSocket,QHttp,QFtp,QProcess也是可重入的，在多个线程中同时使用这些类是可能的。
\item 需要注意的是，这些类被设计成在一个单线程中创建与使用，因此，在一个线程中创建一个对象，而在另外的线程中调用它的函数，这样的行为不能保证工作良好。
\item 有三种约束需要注意：
\begin{itemize}
\item QObject的孩子总是应该在它父亲被创建的那个线程中创建。这意味着，你绝不应该传递QThread对象作为另一个对象的父亲(因为QThread对象本身会在另一个线程中被创建)
\item 事件驱动对象仅仅在单线程中使用。明确地说，这个规则适用于"定时器机制“与”网格模块“，举例来讲，你不应该在一个线程中开始一个定时器或是连接一个套接字，当这个线程不是这些对象所在的线程。
\item 你必须保证在线程中创建的所有对象在你删除QThread前被删除。这很容易做到:你可以run()函数运行的栈上创建对象。
\end{itemize}
\item 尽管QObject是可重入的，但GUI类，特别是QWidget与它的所有子类都是不可重入的。它们仅用于主线程。正如前面提到过的，QCoreApplication::exec()也必须从那个线程中被调用。实践上，不会在别的线程中使用GUI类，它们工作在主线程上，把一些耗时的操作放入独立的工作线程中，当工作线程运行完成，把结果在主线程所拥有的屏幕上显示。
\end{itemize}
\subsection{逐线程事件循环}
\label{sec-2-2}
\begin{itemize}
\item 每个线程可以有它的事件循环，初始线程开始它的事件循环需使用QCoreApplication::exec(),别的线程开始它的事件循环需要用QThread::exec().像QCoreApplication一样，QThread提供了exit(int)函数，一个quit() slot。
\item 线程中的事件循环，使得线程可以使用那些需要事件循环的非GUI 类(如，QTimer,QTcpSocket,QProcess)。也可以把任何线程的signals连接到特定线程的slots，也就是说信号-槽机制是可以跨线程使用的。对于在QApplication之前创建的对象，QObject::thread()返回0,这意味着主线程仅为这些对象处理投递事件，不会为没有所属线程的对象处理另外的事件。
\item 可以用 \textbf{QObject::moveToThread()} 来改变它和它孩子们的线程亲缘关系，假如对象有父亲，它不能移动这种关系。在另一个线程(而不是创建它的那个线程)中delete QObject对象是不安全的。除非你可以保证在同一时刻对象不在处理事件。可以用QObject::deleteLater(),它会投递一个DeferredDelete事件，这会被对象线程的事件循环最终选取到。
\item 假如没有事件循环运行，事件不会分发给对象。举例来说，假如你在一个线程中创建了一个QTimer对象，但从没有调用过exec(),那么QTimer就不会发射它的timeout()信号.对deleteLater()也不会工作。(这同样适用于主线程)。你可以手工使用线程安全的函数QCoreApplication::postEvent()，在任何时候，给任何线程中的任何对象投递一个事件，事件会在那个创建了对象的线程中通过事件循环派发。事件过滤器在所有线程中也被支持，不过它限定被监视对象与监视对象生存在同一线程中。类似地，QCoreApplication::sendEvent(不是postEvent()),仅用于在调用此函数的线程中向目标对象投递事件。
\end{itemize}
\subsection{从别的线程中访问QObject子类}
\label{sec-2-3}
\begin{itemize}
\item QObject和所有它的子类是非线程安全的。这包括整个的事件投递系统。需要牢记的是，当你正从别的线程中访问对象时，事件循环可以向你的QObject子类投递事件。假如你调用一个不生存在当前线程中的QObject子类的函数时，你必须用mutex来保护QObject子类的内部数据，否则会遭遇灾难或非预期结果。像其它的对象一样，QThread对象生存在创建它的那个线程中---不是当QThread::run()被调用时创建的那个线程。一般来讲，在你的QThread子类中提供slots是不安全的，除非你用mutex保护了你的成员变量。
\item 另一方面，你可以安全的从QThread::run()的实现中发射信号，因为信号发射是线程安全的。
\end{itemize}
\subsection{跨线程的信号-槽}
\label{sec-2-4}
\begin{itemize}
\item Qt支持三种类型的信号-槽连接：
\begin{itemize}
\item 1，直接连接，当signal发射时，slot立即调用。此slot在发射signal的那个线程中被执行(不一定是接收对象生存的那个线程(?))
\item 2，队列连接，当控制权回到对象属于的那个线程的事件循环时，slot被调用。此slot在接收对象生存的那个线程中被执行
\item 3，自动连接(缺省)，假如信号发射与接收者在同一个线程中，其行为如直接连接，否则，其行为如队列连接。
\end{itemize}
\item 连接类型可能通过以向connect()传递参数来指定。注意的是，当发送者与接收者生存在不同的线程中，而事件循环正运行于接收者的线程中，使用直接连接是不安全的。同样的道理，调用生存在不同的线程中的对象的函数也是不是安全的。QObject::connect()本身是线程安全的。
\end{itemize}
\subsection{多线程与隐含共享}
\label{sec-2-5}
\begin{itemize}
\item Qt为它的许多值类型使用了所谓的隐含共享(implicit sharing)来优化性能。原理比较简单，共享类包含一个指向共享数据块的指针，这个数据块中包含了真正原数据与一个引用计数。把深拷贝转化为一个浅拷贝，从而提高了性能。这种机制在幕后发生作用，程序员不需要关心它。如果深入点看，假如对象需要对数据进行修改，而引用计数大于1，那么它应该先detach()。以使得它修改不会对别的共享者产生影响，既然修改后的数据与原来的那份数据不同了，因此不可能再共享了，于是它先执行深拷贝，把数据取回来，再在这份数据上进行修改。例如：
\end{itemize}

\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
void QPen::setStyle(Qt::PenStyle style){  
     detach();           // detach from common data  
     d->stylestyle = style;   // set the style member  
}  
void QPen::detach(){   
    if (d->ref != 1) {  
	 ...             // perform a deep copy  
     }  
}
\end{lstlisting}
\begin{itemize}
\item 一般认为，隐含共享与多线程不太和谐，因为有引用计数的存在。对引用计数进行保护的方法之一是使用mutex,但它很慢，Qt早期版本没有提供一个满意的解决方案。从4.0开始，隐含共享类可以安全地跨线程拷贝，如同别的值类型一样。它们是 \textbf{完全可重入} 的。隐含共享真的是"implicit"。它使用汇编语言实现了原子性引用计数操作，这比用mutex快多了。
\item 假如你在多个线程中同进访问相同对象，你也需要用mutex来串行化访问顺序,就如同其他可重入对象那样。总的来讲，隐含共享真的给”隐含“掉了，在多线程程序中，你可以把它们看成是一般的，非共享的，可重入的类型，这种做法是安全的。
\end{itemize}

\section{QThread使用方法: QThread中的slots在那个线程中执行？}
\label{sec-3}
Reference: \url{http://mobile.51cto.com/symbian-268690.htm}
\subsection{QThread::run}
\label{sec-3-1}
\begin{itemize}
\item run 对于线程的作用相当于main函数对于应用程序。它是线程的入口，run的开始和结束意味着线程的开始和结束。 原文如下: The run() implementation is for a thread what the main() entry point is for the application. All code executed in a call stack that starts in the run() function is executed by the new thread, and the thread finishes when the function returns.  
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
class Thread : public QThread {       
    Q_OBJECT
public:       
    Thread(QObject* parent = 0)
	: QThread(parent) {
    }
public slots:       
    void slot() { ... }
signals:       
    void sig();
protected:       
    void run() { ...}
};    

int main(int argc, char** argv) {
    ...
    Thread thread;
    ...
}
\end{lstlisting}
\item 对照前面的定理，run函数中的代码时确定无疑要在次线程中运行的，那么其他的呢？比如 slot 是在次线程还是主线程中运行？
\end{itemize}
\subsection{QObject::connect}
\label{sec-3-2}
\subsubsection{three connection types}
\label{sec-3-2-1}
\begin{enumerate}
\item 自动连接(Auto Connection)
\label{sec-3-2-1-1}
\begin{itemize}
\item 这是默认设置
\item 如果发送者和接收者处于同一线程，则等同于直接连接
\item 如果发送者和接受者位于不同线程，则等同于队列连接
\item 也就是这说，只存在下面两种情况
\end{itemize}
\item 直接连接(Direct Connection)
\label{sec-3-2-1-2}
\begin{itemize}
\item 当信号发射时，槽函数将直接被调用。
\item 无论槽函数所属对象在哪个线程，槽函数都在发射者所在线程执行。
\end{itemize}
\item 队列连接(Queued Connection)
\label{sec-3-2-1-3}
\begin{itemize}
\item 当控制权回到接受者所在线程的事件循环时，槽函数被调用。
\item 槽函数在接收者所在线程执行。
\end{itemize}
\end{enumerate}
\subsubsection{explain by examples}
\label{sec-3-2-2}
\begin{itemize}
\item 不妨继续拿前面的例子来看，slot 函数是在主线程还是次线程中执行呢？
\item 定理二强调两个概念：发送者所在线程 和 接收者所在线程。而 slot 函数属于我们在main中创建的对象 thread，即thread属于主线程
\begin{itemize}
\item 队列连接告诉我们：槽函数在接受者所在线程执行。即 slot 将在主线程执行
\item 直接连接告诉我们：槽函数在发送者所在线程执行。发送者在那个线程呢？？不定！
\item 自动连接告诉我们：二者不在同一线程时，等同于队列连接。即 slot 在主线程执行
\end{itemize}
\item 要彻底理解这几句话，你可能需要看 \textbf{Qt meta-object系统} 和 \textbf{Qt event系统} 
\begin{itemize}
\item QThread 是用来管理线程的，它所处的线程和它管理的线程并不是同一个东西
\item QThread 所处的线程，就是执行 QThread t(0) 或 QThread * t=new QThread(0) 的线程。也就是咱们这儿的主线程
\item QThread 管理的线程，就是 run 启动的线程。也就是次线程
\item 因为QThread的对象在主线程中，所以他的slot函数会在主线程中执行，而不是次线程。除非：QThread 对象在次线程中
\item slot和信号是直接连接，且信号所属对象在次线程中
\end{itemize}
\item 但上两种解决方法都不好，因为QThread不是这么用的(Bradley T. Hughes)
\end{itemize}
\subsection{主线程(信号) \textasciitilde{} QThread(槽)}
\label{sec-3-3}
\begin{itemize}
\item 这是Qt Manual 和 例子中普遍采用的方法。 但由于manual没说槽函数是在主线程执行的，所以不少人都认为它应该是在次线程执行了。
\begin{itemize}
\item 定义一个 Dummy 类，用来发信号
\item 定义一个 Thread 类，用来接收信号
\item 重载 run 函数，目的是打印 threadid
\end{itemize}
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
#include <QtCore/QCoreApplication>   
#include <QtCore/QObject>   
#include <QtCore/QThread>   
#include <QtCore/QDebug>

class Dummy : public QObject {       
    Q_OBJECT
public:     
    Dummy(){}
public slots:
    void emitsig() {
	emit sig();       
    }
signals:
    void sig();   
};    

class Thread : public QThread {      
    Q_OBJECT
public:       
    Thread(QObject* parent = 0)
	: QThread(parent) {
	//moveToThread(this);
    }   
public slots:
    void slot_main () {           
	qDebug() << "from thread slot_main:" << currentThreadId();       
    }
protected:
    void run() {           
	qDebug() << "thread thread:" << currentThreadId();           
	exec();       
    }   
};

//#include "main.moc"
int main(int argc, char *argv[]) {       
    QCoreApplication a(argc, argv);       
    qDebug() << "main thread:" << QThread::currentThreadId();
    Thread thread;       
    Dummy dummy;      
    QObject::connect(&dummy, SIGNAL(sig()), &thread, SLOT(slot_main()));       
    thread.start();      
    dummy.emitsig();       
    return a.exec();
}
\end{lstlisting}
\item 然后看到结果(具体值每次都变，但结论不变)

\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
main thread:           0x1a40 
from thread slot_main: 0x1a40 
thread thread:         0x1a48 

Mine here:
Starting /home/jenny/480/qt/build-dummyThread-Unnamed-Debug/dummyThread...
main thread:           140534496016256 
from thread slot_main: 140534496016256 
thread thread:         140534421948160
\end{lstlisting}
\item 看到了吧，槽函数的线程和主线程是一样的！
\item 如果你看过Qt自带的例子，你会发现 QThread 中 slot 和 run 函数共同操作的对象，都会用QMutex锁住。为什么？因为slot和run处于不同线程，需要线程间的同步！
\item 如果想让槽函数slot在次线程运行(比如它执行耗时的操作，会让主线程死掉)，怎么解决呢？
\item 注意：发送dummy信号是在主线程， 接收者 thread 也在主线程中。 参考我们前面的结论，很容易想到: 将 thread 放到次线程中不就行了 这也是代码中注释掉的 moveToThread(this)所做的，去掉注释，你会发现slot在次线程中运行
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
main thread:           0x13c0 
thread thread:         0x1de0 
from thread slot_main: 0x1de0 

Mine here: 
Starting /home/jenny/480/qt/build-dummyThread-Unnamed-Debug/dummyThread...
main thread:           140371166443392 
thread thread:         140371092375296 
from thread slot_main: 140371092375296
\end{lstlisting}
\item 这可以工作，但这是 Bradley T. Hughes 强烈批判的用法。推荐的方法后面会给出。
\end{itemize}
\subsection{run中信号与QThread中槽}
\label{sec-3-4}
Reference: \url{http://mobile.51cto.com/symbian-268690_1.htm}
\begin{itemize}
\item examples:
\begin{itemize}
\item 定义一个 Dummy 类，在run中发射它的信号
\item 也可以在run中发射 Thread 中的信号，而不是Dummy（效果完全一样），QThread 定义槽函数，重载run函数
\end{itemize}
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
#include <QtCore/QCoreApplication>   
#include <QtCore/QObject>   
#include <QtCore/QThread>   
#include <QtCore/QDebug>    

class Dummy : public QObject {       
    Q_OBJECT
public:
    Dummy(QObject* parent = 0)
	: QObject(parent) {}   
public slots:
    void emitsig() {        
	emit sig();    
    }
signals:
    void sig();
};    

class Thread : public QThread {       
    Q_OBJECT
public:      
    Thread(QObject* parent = 0)
	: QThread(parent) {
	//moveToThread(this);
    }   
public slots:
    void slot_thread() {           
	qDebug() << "from thread slot_thread:"  << currentThreadId();
    }   
signals:
    void sig();
protected:
    void run() {           
	qDebug() << "thread thread:" << currentThreadId();          
	Dummy dummy;           
	connect(&dummy, SIGNAL(sig()), this, SLOT(slot_thread()));          
	dummy.emitsig();
	exec();       
    }   
};    

//#include "main.moc"
int main(int argc, char *argv[]) {       
    QCoreApplication a(argc, argv);       
    qDebug() << "main thread:" << QThread::currentThreadId();       
    Thread thread;       
    thread.start();       
    return a.exec();
}
\end{lstlisting}
\item 想看结果么？

\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
main thread:             0x15c0 
thread thread:           0x1750 
from thread slot_thread: 0x15c0

Mine here: 
Starting /home/jenny/480/qt/build-dummyThread-Unnamed-Debug/dummyThread...
main thread:             140388248221568 
thread thread:           140388174153472 
from thread slot_thread: 140388248221568
\end{lstlisting}
\item 其实没悬念，肯定是主线程
\item thread 对象本身在主线程。所以它的槽也在要在主线程执行，如何解决呢？
\begin{itemize}
\item （方法一）前面提了 moveToThread,这儿可以用，而且可以解决问题。当同样，是被批判的对象。
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
uncomment moveToThread(this); line :
Starting /home/jenny/480/qt/build-dummyThread-Unnamed-Debug/dummyThread...
main thread:             140217092188032 
thread thread:           140217018119936 
from thread slot_thread: 140217018119936
\end{lstlisting}
\item （方法二）注意哦，这儿我们的信号时次线程发出的，对比connect连接方式，会发现：
\begin{itemize}
\item 采用直接连接，槽函数将在次线程(信号发出的线程)执行
\item 这个方法不太好，因为你需要处理slot和它的对象所在线程的同步。需要 QMutex 一类的东西(have \textbf{NOT} tried this method yet\textasciitilde{}!!)
\end{itemize}
\item （方法三）推荐的方法，其实，这个方法太简单，太好用了。定义一个普通的QObject派生类，然后将其对象move到QThread中。使用信号和槽时根本不用考虑多线程的存在。也不用使用QMutex来进行同步，Qt的事件循环会自己自动处理好这个。
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
#include <QtCore/QCoreApplication>   
#include <QtCore/QObject>   
#include <QtCore/QThread>   
#include <QtCore/QDebug>    

class Dummy : public QObject {       
    Q_OBJECT   
public:
    Dummy(QObject* parent = 0)
	: QObject(parent) {}   
public slots:
    void emitsig() {
	emit sig();       
    }
signals:
    void sig();
};

class Object : public QObject {       
    Q_OBJECT   
public:
    Object(){}
public slots:
    void slot() {    
	qDebug() << "from thread slot:"  << QThread::currentThreadId();       
    }   
};    

//#include "main.moc"
int main(int argc, char *argv[]) {      
    QCoreApplication a(argc, argv);       
    qDebug() << "main thread:" << QThread::currentThreadId();      
    QThread thread;       
    Object obj;       
    Dummy dummy;       
    obj.moveToThread(&thread);      
    QObject::connect(&dummy, SIGNAL(sig()), &obj, SLOT(slot()));      
    thread.start();       
    dummy.emitsig();       
    return a.exec();
}
\end{lstlisting}
\begin{itemize}
\item 结果：恩，slot确实不在主线程中运行（这么简单不值得欢呼么？）

\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
main thread:      0x1a5c
from thread slot: 0x186c 

Mine here: 
Starting /home/jenny/480/qt/build-dummyThread-Unnamed-Debug/dummyThread...
main thread:      139964716550016 
from thread slot: 139964642481920
\end{lstlisting}
\end{itemize}
\end{itemize}
\end{itemize}

\section{QT中关于信号与槽机制的实现原理: 源代码分析}
\label{sec-4}
本文介绍的内容是QT中关于信号与槽机制的实现原理，每个对象都有一个相应的纪录该对象的元对象，关于元对象的类在本文中有所介绍。
\subsection{每个对象都有一个相应的纪录该对象的元对象}
\label{sec-4-1}
关于元对象的类：下面介绍有两种
\subsubsection{QMetaObject类}
\label{sec-4-1-1}
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
/*******************生成元对象需要的输入参数*****************/  
// 类名  
const char * const class_name;  

// 父类名  
QMetaObject *superclass;  

// 记录slot信息  
const QMetaData * const slot_data;   

// 记录槽的个数  
int n_slots;  

// 记录signal信息  
const QMetaData * const signal_data;  

// 记录信号的个数  
int n_signals;

/******************* 元对象类提供的方法**************************/  
int numSlots( bool super = FALSE ) const;   // 返回槽的个数  
int numSignals( bool super = FALSE ) const; // 返回信号的个数  
int findSlot( const char *, bool super = FALSE ) const;   // 查找槽  
int findSignal( const char *, bool super = FALSE ) const; // 查找信号  

// 返回指定位置的槽  
const QMetaData *slot( int index, bool super = FALSE ) const;  

// 返回指定位置的信号  
const QMetaData *signal( int index, bool super = FALSE ) const;  

// 所有槽名字的列表  
QStrList slotNames( bool super = FALSE ) const;  

// 所有信号名字的列表  
QStrList signalNames( bool super = FALSE ) const;  

// 槽的起始索引  
int slotOffset() const;  

// 信号的起始索引  
int signalOffset() const;  

/***********************两个获取类的元对象的方法*****************/  
static QMetaObject *metaObject( const char *class_name );  
static bool hasMetaObject( const char *class_name );
\end{lstlisting}
\subsubsection{QMetaData类}
\label{sec-4-1-2}
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
  // 记录元对象数据for 信号与槽  
struct QMetaData {                                   
    const char *name;       // 名称  
    const QUMethod* method; // 详细描述信息  
    enum Access { Private, Protected, Public };  
    Access access;          // 访问权限  
};
\end{lstlisting}

\subsection{QObject类实现了信号与槽机制}
\label{sec-4-2}
它利用元对象纪录的信息，实现了信号与槽机制.
\subsubsection{信号与槽建立连接的实现}
\label{sec-4-2-1}
\begin{enumerate}
\item 接口函数：
\label{sec-4-2-1-1}
\lstset{language=c++,label= ,caption= ,numbers=none}
\begin{lstlisting}
// 连接  
// 参数(发送对象，信号，接收对象，处理信号的信号/槽)
static bool connect(const QObject *sender, const char *signal,  
				    const QObject *receiver, const char *member );  
bool connect(const QObject *sender, const char *signal,  
		     const char *member ) const;

static bool disconnect(const QObject *sender, const char *signal,  
					const QObject *receiver, const char *member);  
bool disconnect(const char *signal = 0,  
				const QObject *receiver = 0, const char *member = 0 );  
bool disconnect(const QObject *receiver, const char *member = 0 );

// 连接的内部实现  
// (发送对象，信号的索引，接收对象，处理信号的类型，处理信号信号/槽的索引)    
static void connectInternal(const QObject *sender, int signal_index,  
						 const QObject *receiver, int membcode, int member_index );  
static bool disconnectInternal(const QObject *sender, int signal_index,  
						 const QObject *receiver, int membcode, int member_index );
\end{lstlisting}
\item 信号与槽连接的实现原理：
\label{sec-4-2-1-2}
\lstset{language=c++,label= ,caption= ,numbers=none}
\begin{lstlisting}
// 一阶段  
bool QObject::connect(const QObject *sender,   // 发送对象        
		      const char *signal,      // 信号  
		      const QObject *receiver, // 接收对象  
		      const char *member       // 槽  
		      ) { 
     // 检查发送对象，信号，接收对象，槽不为null  
    if ( sender == 0 || receiver == 0 || signal == 0 || member == 0 ) {        
	    return false;  
    }

    // 获取发送对象的元对象  
    QMetaObject *smeta = sender->metaObject();  
    // 检查信号  
    if ( !check_signal_macro( sender, signal, "connect", "bind" ) )  
	    return false;     
    // 获取信号的索引  
    int signal_index = smeta->findSignal( signal, true );  
    if ( signal_index < 0 ) {                // normalize and retry  
	    nw_signal = qt_rmWS( signal-1 ); // remove whitespace  
	    signal = nw_signal.data()+1;         // skip member type code  
	    signal_index = smeta->findSignal( signal, true );  
    }  
    // 如果信号不存在，则退出  
    if ( signal_index < 0  ) {                    // no such signal  
	    return false;  
    }  

    // 获取信号的元数据对象  
    const QMetaData *sm = smeta->signal( signal_index, true );  
    // 获取信号名字  
    signal = sm->name;         
    // 获取处理信号的类型（是信号/槽）  
    int membcode = member[0] - '0';        // get member code    // **** membcode
    // 发送信号对象  
    QObject *s = (QObject *)sender;        // we need to change them  
    // 接收信号对象  
    QObject *r = (QObject *)receiver;      //   internally  
    // 获取接收对象的元对象  
    QMetaObject *rrmeta = r->metaObject();  
    int member_index = -1;  

    switch ( membcode ) {                // get receiver member  
    case QSLOT_CODE:// 如果是槽  
	    // 获取槽索引  
	    member_index = rmeta->findSlot( member, true );  
	    if ( member_index < 0 ) {            // normalize and retry  
		    nw_member = qt_rmWS(member);     // remove whitespace  
		    member = nw_member;  
		    member_index = rmeta->findSlot( member, true );  
	    }  
	    break;  
    case QSIGNAL_CODE:// 如果是信号  
	    // 获取信号索引  
	    member_index = rmeta->findSignal( member, true );  
	    if ( member_index < 0 ) {           // normalize and retry  
		    nw_member = qt_rmWS(member);     // remove whitespace  
		    member = nw_member;  
		    member_index = rmeta->findSignal( member, true );  
	    }  
	    break;  
    }  
    // 如果接收对象不存在相应的信号或槽，则退出  
    if ( member_index < 0  ) {  
	    return false;  
    }  
    // 检查连接的参数(发送的信号，接收对象，处理信号的槽或信号)  
    if ( !s->checkConnectArgs(signal,receiver,member) ) {  
	    return false;  
    } else {  
	// 获取处理信号的元数据对象  
	    const QMetaData *rm = membcode == QSLOT_CODE ?  
		rmeta->slot( member_index, true ) :  
		rmeta->signal( member_index, true );  
	    if ( rm ) {            
		    // 建立连接  
		    // (发送信号的对象，信号的索引，接收信号的对象，处理信号的类型，处理信号的索引)  
		    connectInternal( sender, signal_index, receiver, membcode, member_index );  
	    }  
    }  
    return true;  
}  

// 二阶段  
// 建立连接  
// (发送信号的对象，信号的索引，接收信号的对象，处理信号的类型，处理信号的索引)  
void QObject::connectInternal( const QObject *sender, int signal_index,   
			       const QObject *receiver, int membcode, int member_index )   {  
    // 发送信号的对象  
    QObject *s = (QObject*)sender;  
    // 接收信号的对象  
    QObject *r = (QObject*)receiver;  
    // 如果发送对象的连接查询表为null，则建立  
    if ( !s->connections ) {                // create connections lookup table  
	    s->connections = new QSignalVec( signal_index+1 );  
	    Q_CHECK_PTR( s->connections );  
	    s->connections->setAutoDelete( true );  
    }  
    // 获取发送对象的相应信号的连接列表  
     QConnectionList *clist = s->connections->at( signal_index );  
    if ( !clist ) {                         // create receiver list  
	    clist = new QConnectionList;  
	    Q_CHECK_PTR( clist );  
	    clist->setAutoDelete( true );  
	    s->connections->insert( signal_index, clist );  
    }  
    QMetaObject *rrmeta = r->metaObject();  
    const QMetaData *rm = 0;  
    switch ( membcode ) {                // get receiver member  
    case QSLOT_CODE:  
	    rm = rmeta->slot( member_index, true );  
	    break;  
    case QSIGNAL_CODE:  
	    rm = rmeta->signal( member_index, true );  
	    break;  
    }  
    // 建立连接  
    QConnection *c = new QConnection( r, member_index, rm ? rm->name : "qt_invoke", membcode );  
    Q_CHECK_PTR( c );  
    // 把连接添加到发送对象的连接列表中  
    clist->append( c );  
    // 判断接收对象的发送对象列表是否为null  
    if ( !r->senderObjects ) {               // create list of senders 
	    // 建立接收对象的发送对象列表  
	    r->senderObjects = new QSenderObjectList;  
    }  
    // 把发送对象添加到发送对象列表中  
    r->senderObjects->append( s );           // add sender to list  
}
\end{lstlisting}
\item 信号发生时激活的操作函数。 激活slot的方法
\label{sec-4-2-1-3}
\lstset{language=java,label= ,caption= ,numbers=none}
\begin{lstlisting}
// 接口：
void QObject::activate_signal( int signal ) {  
    #ifndef QT_NO_PRELIMINARY_SIGNAL_SPY  
    if ( qt_preliminary_signal_spy ) {  
	    //信号没有被阻塞  
	    //信号>=0  
	    //连接列表不为空，或者信号对应的连接存在  
	    if ( !signalsBlocked() && signal >= 0 &&  
		     ( !connections || !connections->at( signal ) ) ) {  
		    //  
		    QUObject o[1];  
		    qt_spy_signal( this, signal, o );  
		    return;  
	    }  
    }  
    #endif  
    if ( !connections || signalsBlocked() || signal < 0 )  
	    return;  
    //获取信号对应的连接列表  
    QConnectionList *clist = connections->at( signal );  
    if ( !clist )  
	    return;  
    QUObject o[1];  
    //  
    activate_signal( clist, o );  
}  

void QObject::activate_signal( QConnectionList *clist, QUObject *o )   {  
    if ( !clist )  
	    return;  
#ifndef QT_NO_PRELIMINARY_SIGNAL_SPY  
    if ( qt_preliminary_signal_spy )  
	    qt_spy_signal( this, connections->findRef( clist), o );  
#endif  
    QObject *object;  
    //发送对象列表  
    QSenderObjectList* sol;  
    //旧的发送对象  
    QObject* oldSender = 0;  
    //连接  
    QConnection *c;  
    if ( clist->count() == 1 ) { // save iterator  
	    //获取连接  
	    c = clist->first();  
	    //  
	    object = c->object();  
	    //获取发送对象列表  
	    sol = object->senderObjects;  
	    if ( sol ) {  
		//获取旧的发送对象  
		oldSender = sol->currentSender;  
		//  
		sol->ref();  
		//设置新的发送对象  
		sol->currentSender = this;  
	    }  
	    if ( c->memberType() == QSIGNAL_CODE )//如果是信号，则发送出去  
		    object->qt_emit( c->member(), o );  
	    else  
		    object->qt_invoke( c->member(), o );//如果是槽，则执行  
	    //       
	    if ( sol ) {  
		    //设置恢复为旧的发送对象  
		    sol->currentSender = oldSender;  
		    if ( sol->deref() )  
			    delete sol;  
	    }  
    } else {  
	    QConnection *cd = 0;  
	    QConnectionListIt it(*clist);  
	    while ( (c=it.current()) ) {  
		    ++it;  
		    if ( c == cd )  
			    continue;  
		    ccd = c;   
		   object = c->object();  
		    //操作前设置当前发送对象  
		    sol = object->senderObjects;  
		    if ( sol ) {  
			    oldSender = sol->currentSender;  
			    sol->ref();  
			    sol->currentSender = this;  
		    }  
		    //如果是信号，则发送出去  
		    if ( c->memberType() == QSIGNAL_CODE ){  
			    object->qt_emit( c->member(), o );  
		    }  
		    //如果是槽，则执行  
		    else {  
			    object->qt_invoke( c->member(), o );  
		    }  
		    //操作后恢复当前发送对象  
		    if (sol ) {  
			    sol->currentSender = oldSender;  
			    if ( sol->deref() )  
				    delete sol;  
		    }  
	    } // while  
    }  
}
\end{lstlisting}
\end{enumerate}

\section{QT中实现Thread与GUI主线程连通方法}
\label{sec-5}
\subsection{}
\label{sec-5-1}
% Emacs 24.3.1 (Org mode 8.2.7c)
\end{document}